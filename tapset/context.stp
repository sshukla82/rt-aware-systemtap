// context tapset
// Copyright (C) 2005, 2006, 2007 Red Hat Inc.
// Copyright (C) 2006 Intel Corporation.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

function print_regs
    @@ "Print a register dump (for kprobes, uprobes, profiling)."
    () 
%{
    	if (CONTEXT->regs) {
	   	_stp_print_regs (CONTEXT->regs);
	}
%}

function print_backtrace
    @@ "Equivalent to print_stack(backtrace()), except that"
    @@ "deeper stack nesting may be supported."
    () 
%{
	if (CONTEXT->regs) {
		_stp_stack_print(CONTEXT->regs, 1, CONTEXT->pi);
	} else {
		_stp_printf("Systemtap probe: %s\n", CONTEXT->probe_point);
	}
%}

function backtrace:string 
    @@ "Return a string of hex addresses that are a backtrace of the stack."
    @@ "It may be truncated due to maximum string length."
    ()
%{ /* pure */
	if (CONTEXT->regs)
		_stp_stack_snprint (THIS->__retvalue, MAXSTRINGLEN, CONTEXT->regs, 0, CONTEXT->pi);	
	else 
		strlcpy (THIS->__retvalue, "", MAXSTRINGLEN);
%}

function execname:string 
    @@ "Return the name of the current process."
    ()
%{ /* pure */
	strlcpy (THIS->__retvalue, current->comm, MAXSTRINGLEN);
%}

function pid:long () %{ /* pure */
	THIS->__retvalue = current->tgid;
%}

function tid:long () %{ /* pure */
	THIS->__retvalue = current->pid;
%}

function ppid:long () %{ /* pure */
	THIS->__retvalue = current->parent->tgid;
%}

function pexecname:string () %{ /* pure */
	strlcpy (THIS->__retvalue, current->parent->comm, MAXSTRINGLEN);
%}

function gid:long () %{ /* pure */
	THIS->__retvalue = current->gid;		
%}

function egid:long () %{ /* pure */
	THIS->__retvalue = current->egid;		
%}

function uid:long () %{ /* pure */
	THIS->__retvalue = current->uid;		
%}

function euid:long () %{ /* pure */
	THIS->__retvalue = current->euid;		
%}

function cpuid:long () %{ /* pure */
	THIS->__retvalue = smp_processor_id();
%}

function cpu:long () %{ /* pure */
	THIS->__retvalue = smp_processor_id();
%}

function print_stack(stk:string) %{
	char *ptr = THIS->stk;
	char *tok = strsep(&ptr, " ");
	while (tok && *tok) {
		_stp_print_char(' ');
		_stp_symbol_print (simple_strtol(tok, NULL, 16));
		_stp_print_char('\n');
		tok = strsep(&ptr, " ");
	}
%}

function pp:string () %{ /* pure */
	strlcpy (THIS->__retvalue, CONTEXT->probe_point, MAXSTRINGLEN);
%}

function probefunc:string () %{ /* pure */
	char *ptr, *start;

	start = strstr(CONTEXT->probe_point, "function(\"");
	ptr = start + 10; 
	if (!start) {
		start = strstr(CONTEXT->probe_point, "inline(\"");
		ptr = start + 8;
	}

	if (start) {
		int len = MAXSTRINGLEN;
		char *dst = THIS->__retvalue;
		while (*ptr != '@' && --len > 0 && *ptr)
			*dst++ = *ptr++;
		*dst = 0;

	} else if (CONTEXT->regs &&
#if defined (__ia64__)
		((unsigned long)REG_IP(CONTEXT->regs) >= (unsigned long)KERNEL_START)) {
#else
		((unsigned long)REG_IP(CONTEXT->regs) >= (unsigned long)PAGE_OFFSET)) {
#endif
		_stp_symbol_snprint(THIS->__retvalue, MAXSTRINGLEN, REG_IP(CONTEXT->regs));
       	         if (THIS->__retvalue[0] == '.')  /* powerpc symbol has a dot*/
       	         	strlcpy(THIS->__retvalue,THIS->__retvalue + 1,MAXSTRINGLEN);
	} else {
		THIS->__retvalue[0] = '\0';
	}
%}

function probemod:string () %{ /* pure */
	char *ptr, *start;

	start = strstr(CONTEXT->probe_point, "module(\"");
	ptr = start + 8;

	if (start) {
		int len = MAXSTRINGLEN;
		char *dst = THIS->__retvalue;
		while (*ptr != '"' && --len && *ptr)
			*dst++ = *ptr++;
		*dst = 0;
	} else {
		/* XXX: need a PC- and symbol-table-based fallback. */
		THIS->__retvalue[0] = '\0';
	}
%}

function is_return:long () %{ /* pure */
	if (CONTEXT->pi)
		THIS->__retvalue = 1;
	else	
		THIS->__retvalue = 0;	
%}

function target:long () %{ /* pure */
        THIS->__retvalue = _stp_target;
%}

function module_name:string () %{ /* pure */
	strlcpy(THIS->__retvalue, THIS_MODULE->name, MAXSTRINGLEN);
%}

function stp_pid:long () %{ /* pure */
        THIS->__retvalue = _stp_pid;
%}

# return the size of the stack
function stack_size:long () %{ /* pure */
        THIS->__retvalue = THREAD_SIZE;
%}

# return how many bytes are currently used in the stack
function stack_used:long () %{ /* pure */
	char a;
        THIS->__retvalue = THREAD_SIZE - ((long)&a & (THREAD_SIZE-1));
%}

# return how many bytes are currently unused in the stack
function stack_unused:long () %{ /* pure */
	char a;
        THIS->__retvalue = (long)&a & (THREAD_SIZE-1);
%}

# Return the address of the calling function. Works only for
# return probes at this time.
function caller_addr:long () %{ /* pure */
        if (CONTEXT->pi)
		THIS->__retvalue = (int64_t)(long)_stp_ret_addr_r(CONTEXT->pi);
        else
		THIS->__retvalue = 0;
%}

# Return the address and name of the calling function. Works 
# only for return probes at this time.
function caller:string() %{ /* pure */
        if (CONTEXT->pi) 
		_stp_symbol_snprint( THIS->__retvalue, MAXSTRINGLEN, 
			(unsigned long)_stp_ret_addr_r(CONTEXT->pi));
        else
		strlcpy(THIS->__retvalue,"unknown",MAXSTRINGLEN);
%}
