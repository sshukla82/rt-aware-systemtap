// nfs tapset
// Copyright (C) 2006-2007 IBM Corp.
// Copyright (C) 2007 Intel Corporation.
// Copyright (C) 2007 Bull S.A.S
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.


%{
#include <linux/sunrpc/svc.h>
#include <linux/nfsd/nfsd.h>
#include <linux/nfsd/cache.h>
#include <linux/nfsd/xdr.h>
#include <linux/nfsd/xdr3.h>
%}

/*
 *1 : nfsd.proc2.lookup
 *2 : nfsd.proc3.lookup
 *3 : nfsd.proc2.read
 *4 : nfsd.proc3.read
 *5 : nfsd.proc2.write
 *6 : nfsd.proc3.write
 *7 : nfsd.proc3.commit
 *8 : nfsd.proc2.create
 *9 : nfsd.proc3.create
 *10: nfsd.proc2.remove
 *11: nfsd.proc3.remove
 *12 :nfsd.proc2.rename.ffh
 *13 :nfsd.proc2.rename.tfh
 *14 :nfsd.proc3.rename.ffh
 *15 :nfsd.proc3.rename.tfh
 */

/*Get file handler from argp,the index indicates the type of argp*/
function __get_fh:long(argp:long,index:long) %{ /* pure */
	int index = (int)((long)THIS->index);
	struct nfsd_diropargs * argp = NULL ;
	struct nfsd3_diropargs * argp3 = NULL ;
	struct nfsd_readargs * argpr = NULL;
	struct nfsd3_readargs * argpr3 = NULL;
	struct nfsd_writeargs * argpw = NULL;
	struct nfsd3_writeargs * argpw3 = NULL;
	struct nfsd3_commitargs * argpc3 = NULL;
	struct nfsd_createargs *argpcr = NULL;
	struct nfsd3_createargs *argpcr3 = NULL;
	struct nfsd_diropargs *argpre = NULL;
	struct nfsd3_diropargs *argpre3 = NULL;
	struct nfsd_renameargs *argpren = NULL;
	struct nfsd3_renameargs *argpren3 = NULL;
	struct svc_fh * fhp = NULL;

	switch(index)
	{
	case 1: argp = (struct nfsd_diropargs *)((long)THIS->argp);
		fhp = &argp->fh;
		break;
	case 2: argp3 = (struct nfsd3_diropargs *)((long)THIS->argp);
		fhp = &argp3->fh;
		break;
	case 3: argpr = (struct nfsd_readargs * )((long)THIS->argp);
		fhp = &argpr->fh;
		break;
	case 4: argpr3 = (struct nfsd3_readargs * )((long)THIS->argp);
		fhp = &argpr3->fh;
		break;
	case 5: argpw = (struct nfsd_writeargs * )((long)THIS->argp);
		fhp = &argpw->fh;
		break;
	case 6: argpw3 = (struct nfsd3_writeargs * )((long)THIS->argp);
		fhp = &argpw3->fh;
		break;
	case 7: argpc3 = (struct nfsd3_commitargs * )((long)THIS->argp);
		fhp = &argpc3->fh;
		break;
	case 8: argpcr = (struct nfsd_createargs * )((long)THIS->argp);
		fhp = &argpcr->fh;
		break;
	case 9: argpcr3 = (struct nfsd3_createargs * )((long)THIS->argp);
		fhp = &argpcr3->fh;
		break;
	case 10: argpre = (struct nfsd_diropargs * )((long)THIS->argp);
		fhp = &argpre->fh;
		break;
	case 11: argpre3 = (struct nfsd3_diropargs * )((long)THIS->argp);
		fhp = &argpre3->fh;
		break;
	case 12: argpren = (struct nfsd_renameargs * )((long)THIS->argp);
		fhp = &argpren->ffh;
		break;
	case 13: argpren = (struct nfsd_renameargs * )((long)THIS->argp);
		fhp = &argpren->tfh;
		break;
	case 14: argpren3 = (struct nfsd3_renameargs * )((long)THIS->argp);
		fhp = &argpren3->ffh;
		break;
	case 15: argpren3 = (struct nfsd3_renameargs * )((long)THIS->argp);
		fhp = &argpren3->tfh;
		break;
	}
	
	THIS->__retvalue = (long)fhp;
%}
/*Get file handler from struct svc_fh */
function __svc_fh:string(fh :long) %{  /* pure */
	struct svc_fh * fhp = (struct svc_fh *) (long)(THIS->fh);
	struct knfsd_fh *fh = &fhp->fh_handle;

	snprintf(THIS->__retvalue, MAXSTRINGLEN,
			"%d: %08x %08x %08x %08x %08x %08x",
			kread(&(fh->fh_size)),
			kread(&(fh->fh_base.fh_pad[0])),
			kread(&(fh->fh_base.fh_pad[1])),
			kread(&(fh->fh_base.fh_pad[2])),
			kread(&(fh->fh_base.fh_pad[3])),
			kread(&(fh->fh_base.fh_pad[4])),
			kread(&(fh->fh_base.fh_pad[5])));
	CATCH_DEREF_FAULT();
%}

function p_long:long(cnt:long) %{ /* pure */
	unsigned long * count = (unsigned long *)((long)THIS->cnt);
	
	THIS->__retvalue = kread(count);
	CATCH_DEREF_FAULT();
%}
/*
*probe nfsd.dispatch
*  Fires when server receives a NFS operation from client 
*
*Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  xid : transmission id
*  prog : program number
*  proc : procedure number
*/
probe nfsd.dispatch = kernel.function("nfsd_dispatch")!,
                      module("nfsd").function("nfsd_dispatch") ?
{
	client_ip = addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
	version = $rqstp->rq_vers

	xid = $rqstp->rq_xid
	prog = $rqstp->rq_prog
	proc = $rqstp->rq_proc

	name = "nfsd.dispatch"
	argstr = sprintf("%d,%d",version,proto)
}

probe nfsd.dispatch.return = kernel.function("nfsd_dispatch").return!,
                      module("nfsd").function("nfsd_dispatch").return ?
{
	name = "nfsd.dispatch.return"
	retstr = sprintf("%d",$return)
}

probe nfsd.proc.entries = nfsd.proc.lookup,
                          nfsd.proc.read,
                          nfsd.proc.write,
                          nfsd.proc.commit,
                          nfsd.proc.compound,
                          nfsd.proc.remove,
                          nfsd.proc.rename,
			  nfsd.proc.create
{} 

probe nfsd.proc.return = nfsd.proc.lookup.return,
                          nfsd.proc.read.return,
                          nfsd.proc.write.return,
                          nfsd.proc.commit.return,
                          nfsd.proc.compound.return,
                          nfsd.proc.remove.return,
                          nfsd.proc.rename.return,
                          nfsd.proc.create.return
{} 

/*
*probe nfsd.proc.lookup
*  Fires when client opens/searchs file on server
*
*Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  fh  : file handle of parent dir (the first part is the length of the file handle)
*  filename : file name 
*  filelen  : the length of file name
*/
probe nfsd.proc.lookup = nfsd.proc2.lookup,
                         nfsd.proc3.lookup
{}

probe nfsd.proc.lookup.return = nfsd.proc2.lookup.return,
                         nfsd.proc3.lookup.return
{}

probe nfsd.proc2.lookup = kernel.function("nfsd_proc_lookup") !,
                          module("nfsd").function("nfsd_proc_lookup") ?
{
	client_ip = addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 2
	fh = __get_fh($argp,1)

	filelen = $argp->len
	filename = kernel_string_n($argp->name, filelen)

	name = "nfsd.proc2.lookup"
	argstr = sprintf("%s",filename)
}

 
probe nfsd.proc2.lookup.return = kernel.function("nfsd_proc_lookup").return !,
                          module("nfsd").function("nfsd_proc_lookup").return ?
{
	name = "nfsd.proc2.lookup.return"
	version = 2
	retstr = sprintf("%d",$return)
}

probe nfsd.proc3.lookup = kernel.function("nfsd3_proc_lookup") !,
                          module("nfsd").function("nfsd3_proc_lookup") ?
{
	client_ip = addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,1)

	filelen = $argp->len
	filename  = kernel_string_n($argp->name, filelen)

	name = "nfsd.proc3.lookup"
	argstr = sprintf("%s",filename)
} 

probe nfsd.proc3.lookup.return = kernel.function("nfsd3_proc_lookup").return !,
                          module("nfsd").function("nfsd3_proc_lookup").return ?
{
	name = "nfsd.proc3.lookup.return"
	version = 3
	retstr = sprintf("%d",$return)
}


/*
*probe nfsd.proc.read
*  Fires when client read file on server
*
*Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  fh  : file handle (the first part is the length of the file handle)
*  size:
*  count : read bytes
*  offset : the offset of file 
*  vec : struct kvec ,includes buf address in kernel address
         and length of each buffer
*  vlen : read blocks 
*/
probe nfsd.proc.read = nfsd.proc2.read,
                       nfsd.proc3.read
{}

probe nfsd.proc.read.return = nfsd.proc2.read.return,
                       nfsd.proc3.read.return
{

}

probe nfsd.proc2.read = kernel.function("nfsd_proc_read")!,
                        module("nfsd").function("nfsd_proc_read")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 2
	fh = __get_fh($argp,3)

	count = $argp->count 
	offset = $argp->offset 
%( kernel_v >= "2.6.19" %?
	vec = $rqstp->rq_vec
%:
	vec = $argp->vec
%)
	vlen = $argp->vlen

	name = "nfsd.proc2.read"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

 
probe nfsd.proc2.read.return = kernel.function("nfsd_proc_read").return!,
                        module("nfsd").function("nfsd_proc_read").return?
{
	name = "nfsd.proc2.read.return"
	version = 2
	retstr = sprintf("%d",$return)
}

probe nfsd.proc3.read = kernel.function("nfsd3_proc_read")!,
                        module("nfsd").function("nfsd3_proc_read")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,4)

	count = $argp->count 
	offset = $argp->offset 
%( kernel_v >= "2.6.19" %?
	vec = $rqstp->rq_vec
%:
	vec = $argp->vec
%)
	vlen = $argp->vlen

	name = "nfsd.proc3.read"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

 
probe nfsd.proc3.read.return = kernel.function("nfsd3_proc_read").return!,
                        module("nfsd").function("nfsd3_proc_read").return?
{
	name = "nfsd.proc3.read.return"
	version = 3
	retstr = sprintf("%d",$return)
}

/*
*probe nfsd.proc.write
*  Fires when client writes data to  file on server
*
*Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  fh  : file handle (the first part is the length of the file handle)
*  size:
*  count : read bytes
*  offset : the offset of file 
*  vec : struct kvec ,includes buf address in kernel address
         and length of each buffer
*  vlen : read blocks 
*  stable : argp->stable(only in nfs.proc3.write)
*/
probe nfsd.proc.write = nfsd.proc2.write,
                       nfsd.proc3.write
{}

probe nfsd.proc.write.return = nfsd.proc2.write.return,
                       nfsd.proc3.write.return
{

}

probe nfsd.proc2.write = kernel.function("nfsd_proc_write")!,
                        module("nfsd").function("nfsd_proc_write")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 2
	fh = __get_fh($argp,5)

	count = $argp->len
	offset = $argp->offset 
%( kernel_v >= "2.6.19" %?
	vec = $rqstp->rq_vec
%:
	vec = $argp->vec
%)
	vlen = $argp->vlen

	name = "nfsd.proc2.write"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

 
probe nfsd.proc2.write.return = kernel.function("nfsd_proc_write").return!,
                        module("nfsd").function("nfsd_proc_write").return?
{
	name = "nfsd.proc2.write.return"
	version = 2
	retstr = sprintf("%d",$return)
}

probe nfsd.proc3.write = kernel.function("nfsd3_proc_write")!,
                        module("nfsd").function("nfsd3_proc_write")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,6)

	count = $argp->count 
	offset = $argp->offset 
%( kernel_v >= "2.6.19" %?
	vec = $rqstp->rq_vec
%:
	vec = $argp->vec
%)
	vlen = $argp->vlen
	stable = $argp->stable

	name = "nfsd.proc3.write"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

 
probe nfsd.proc3.write.return = kernel.function("nfsd3_proc_write").return!,
                        module("nfsd").function("nfsd3_proc_write").return?
{
	name = "nfsd.proc3.write.return"
	version = 3
	retstr = sprintf("%d",$return)
}

/*
*probe nfsd.proc.commit
*  Fires when client does a commit operation,which is
*  used to flush the data written by async operation before
*  to disk
*
*Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  fh  : file handle (the first part is the length of the file handle)
*  size:
*  count : read bytes
*  offset : the offset of file 
*/
probe nfsd.proc.commit =  nfsd.proc3.commit
{}

probe nfsd.proc.commit.return = nfsd.proc3.commit.return
{

}

probe nfsd.proc3.commit = kernel.function("nfsd3_proc_commit")!,
                        module("nfsd").function("nfsd3_proc_commit")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,7) 

	count = $argp->count 
	offset = $argp->offset 

	name = "nfsd.proc3.commit"
	argstr = sprintf("%d,%d",count,offset)

        size = count
        units = "bytes"
}

probe nfsd.proc3.commit.return = kernel.function("nfsd3_proc_commit").return!,
                        module("nfsd").function("nfsd3_proc_commit").return?
{
	name = "nfsd.proc3.commit.return"
	version = 3
	retstr = sprintf("%d",$return)
}

/*
*probe nfsd.proc.create
* Fires when clients create a file on server side.
*
* Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  fh  : file handle (the first part is the length of the file handle)
*  filename : file name
*  filelen : length of file name
*/
probe nfsd.proc.create = nfsd.proc2.create,
                         nfsd.proc3.create
{}
probe nfsd.proc.create.return = nfsd.proc2.create.return,
                                nfsd.proc3.create.return
{}

probe nfsd.proc2.create = kernel.function("nfsd_proc_create")!,
                         module("nfsd").function("nfsd_proc_create")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 2
	fh = __get_fh($argp,8)

	filelen = $argp->len
	filename  = kernel_string_n($argp->name, filelen)

	name = "nfsd.proc2.create"
	argstr = sprintf("%s",filename)
}

probe nfsd.proc2.create.return =  kernel.function("nfsd_proc_create").return!,
                                 module("nfsd").function("nfsd_proc_create").return?
{
	name = "nfsd.proc2.create.return"
	version = 2
	retstr = sprintf("%d",$return)
}

probe nfsd.proc3.create = kernel.function("nfsd3_proc_create")!,
                         module("nfsd").function("nfsd3_proc_create")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,9)

	filelen = $argp->len
	filename  = kernel_string_n($argp->name, filelen)
	
	name = "nfsd.proc3.create"
	argstr = sprintf("%s",filename)
}

probe nfsd.proc3.create.return =  kernel.function("nfsd3_proc_create").return!,
                                 module("nfsd").function("nfsd3_proc_create").return?
{
	name = "nfsd.proc3.create.return"
	version = 3
	retstr = sprintf("%d",$return)
}

/*
*probe nfsd.proc.remove
* Fires when clients removes a file on server side.
*
* Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  fh  : file handle (the first part is the length of the file handle)
*  filename : file name
*  filelen : length of file name
*/
probe nfsd.proc.remove = nfsd.proc2.remove,
                         nfsd.proc3.remove
{}
probe nfsd.proc.remove.return = nfsd.proc2.remove.return,
                                nfsd.proc3.remove.return
{}

probe nfsd.proc2.remove = kernel.function("nfsd_proc_remove")!,
                         module("nfsd").function("nfsd_proc_remove")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 2
	fh = __get_fh($argp,10)

	filelen = $argp->len
	filename  = kernel_string_n($argp->name, filelen)

	name = "nfsd.proc2.remove"
	argstr = sprintf("%s",filename)
}

probe nfsd.proc2.remove.return =  kernel.function("nfsd_proc_remove").return!,
                                 module("nfsd").function("nfsd_proc_remove").return?
{
	name = "nfsd.proc2.remove.return"
	version = 2
	retstr = sprintf("%d",$return)
}

probe nfsd.proc3.remove = kernel.function("nfsd3_proc_remove")!,
                         module("nfsd").function("nfsd3_proc_remove")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,11)

	filelen = $argp->len
	filename  = kernel_string_n($argp->name, filelen)
	
	name = "nfsd.proc3.remove"
	argstr = sprintf("%s",filename)
}

probe nfsd.proc3.remove.return =  kernel.function("nfsd3_proc_remove").return!,
                                 module("nfsd").function("nfsd3_proc_remove").return?
{
	name = "nfsd.proc3.remove.return"
	version = 3
	retstr = sprintf("%d",$return)
}

/*
* probe nfsd.proc.rename
*  Fires when clients rename a file on server side
*
* Arguments:
*   fh : file handler of old path
*   tfh : file handler of new path
*   filename : old file name 
*   tname : new file name
*   flen : length of old file name 
*   tlen : length of new file name
*/
probe nfsd.proc.rename = nfsd.proc2.rename,
                         nfsd.proc3.rename
{}

probe nfsd.proc.rename.return = nfsd.proc2.rename.return,
                         nfsd.proc3.rename.return
{}

probe nfsd.proc2.rename =  kernel.function("nfsd_proc_rename")!,
                           module("nfsd").function("nfsd_proc_rename")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 2
	fh = __get_fh($argp,12)
	tfh = __get_fh($argp,13)

	filelen = $argp->flen
	filename  = kernel_string_n($argp->fname, filelen)	
	tlen = $argp->tlen
	tname = kernel_string_n($argp->tname, tlen)

	name = "nfsd.proc2.rename"
	argstr = sprintf("%s,%s",filename,tname)
}

probe nfsd.proc2.rename.return =  kernel.function("nfsd_proc_rename").return!,
                           module("nfsd").function("nfsd_proc_rename").return?
{
	name = "nfsd.proc2.rename.return"
	version = 2
	retstr = sprintf("%d",$return)
}

probe nfsd.proc3.rename =  kernel.function("nfsd3_proc_rename")!,
                           module("nfsd").function("nfsd3_proc_rename")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 3
	fh = __get_fh($argp,14)
	tfh = __get_fh($argp,15)

	filelen = $argp->flen
	filename  = kernel_string_n($argp->fname, filelen)	
	tlen = $argp->tlen
	tname = kernel_string_n($argp->tname, tlen)

	name = "nfsd.proc3.rename"
	argstr = sprintf("%s,%s",filename,tname)
}

probe nfsd.proc3.rename.return =  kernel.function("nfsd3_proc_rename").return!,
                           module("nfsd").function("nfsd3_proc_rename").return?
{
	name = "nfsd.proc3.rename.return"
	version = 3
	retstr = sprintf("%d",$return)
}
/*
*probe nfsd.proc.compound
*   Fires when the server received a NFSV4 operation from client
*
*Arguments:
*  client_ip : the ip address of client
*  proto : transfer protocol
*  version : nfs version
*  num : number of file operation in this RPC operation 
*  op : head of operation list in this compound execution
*/
probe nfsd.proc.compound = nfsd.proc4.compound
{}

probe nfsd.proc.compound.return = nfsd.proc4.compound.return
{}

probe nfsd.proc4.compound = kernel.function("nfsd4_proc_compound")!,
                            module("nfsd").function("nfsd4_proc_compound")?
{
	client_ip =  addr_from_rqst($rqstp)
	proto = $rqstp->rq_prot
        version = 4

	num = $args->opcnt
	op = $args->ops
	
	name = "nfsd.proc4.compound"
	argstr = sprintf("%d",num)
}

probe nfsd.proc4.compound.return = kernel.function("nfsd4_proc_compound").return!,
                            module("nfsd").function("nfsd4_proc_compound").return?
{
	name = "nfsd.proc4.compound.return"
	version = 4
	retstr = sprintf("%d",$return)
}

probe nfsd.entries = nfsd.open,
	             nfsd.read,
                     nfsd.write,
                     nfsd.lookup,
                     nfsd.commit,
                     nfsd.create,
                     nfsd.createv3,
                     nfsd.unlink,
                     nfsd.rename,
                     nfsd.close
{}

probe nfsd.return = nfsd.open.return,
	             nfsd.read.return,
                     nfsd.write.return,
                     nfsd.lookup.return,
                     nfsd.commit.return,
                     nfsd.create.return,
                     nfsd.createv3.return,
                     nfsd.unlink.return,
                     nfsd.rename.return
{}
/*probe nfsd.open
*  Fires when server opens a file
*
* Arguments:
*  fh  : file handle (the first part is the length of the file handle)
*  access : indicates the type of open(read/write/commit/readdir...) 
*  type : type of file(regular file or dir)
*/
probe nfsd.open = kernel.function("nfsd_open") !,
                  module("nfsd").function("nfsd_open")?
{
	fh = __svc_fh($fhp)

	access = $access
	type = $type

	name = "nfsd.open"
	argstr = sprintf("%d",access)
}

probe nfsd.open.return = kernel.function("nfsd_open").return !,
                  module("nfsd").function("nfsd_open").return?
{
	name = "nfsd.open.return"
	retstr = sprintf("%d",$return)
}

/*probe nfsd.close
*  Fires when server closes a file
*
* Arguments:
* filename : file name
*/
probe nfsd.close = kernel.function("nfsd_close")!,
                   module("nfsd").function("nfsd_close")?
{
	filename = __file_filename($filp)

	name = "nfsd.close"
	argstr = sprintf("%s",filename)
}

probe nfsd.close.return = kernel.function("nfsd_close").return!,
                   module("nfsd").function("nfsd_close").return?
{}
/*probe nfsd.read
*  Fires when server reads data from a file
*
* Arguments:
*  fh  : file handle (the first part is the length of the file handle)
*  file : argument file,indicates if the file has been opened.
*  size:
*  count : read bytes
*  offset : the offset of file 
*  vec : struct kvec ,includes buf address in kernel address
         and length of each buffer
*  vlen : read blocks 
*/
probe nfsd.read = kernel.function("nfsd_read") !,
                  module("nfsd").function("nfsd_read")?
{
	fh = __svc_fh($fhp)

%( kernel_v >= "2.6.12" %?
	file = $file
%)
	count = p_long($count)
	offset = $offset
	vec = $vec
	vlen = $vlen

	name = "nfsd.read"
	argstr = sprintf("%d,%d",count,offset)

	size = count
	units = "bytes"
} 

probe nfsd.read.return = kernel.function("nfsd_read").return !,
                  module("nfsd").function("nfsd_read").return?
{
	name = "nfsd.read.return"
	retstr = sprintf("%d",$return)
}

/*probe nfsd.write
*  Fires when server writes data to a file
*
* Arguments:
*  fh  : file handle (the first part is the length of the file handle)
*  file : argument file,indicates if the file has been opened.
*  size:
*  count : read bytes
*  offset : the offset of file 
*  vec : struct kvec ,includes buf address in kernel address
         and length of each buffer
*  vlen : read blocks 
*/
probe nfsd.write = kernel.function("nfsd_write")!,
                   module("nfsd").function("nfsd_write")?
{
	fh = __svc_fh($fhp)

%( kernel_v >= "2.6.12" %?
	file = $file
%)
	count = $cnt
	offset = $offset
	vec = $vec
	vlen = $vlen

	name = "nfsd.write"
	argstr = sprintf("%d,%d",count,offset)

	size = count
	units = "bytes"
}

probe nfsd.write.return = kernel.function("nfsd_write").return!,
                   module("nfsd").function("nfsd_write").return?
{
	name = "nfsd.write.return"
	retstr = sprintf("%d",$return)
}

/*probe nfsd.commit
*  Fires when server commits all pending writes to stable storage.  
*
* Arguments:
*  fh  : file handle (the first part is the length of the file handle)
*  flag : indicates whether this execution is a sync operation
*  size:
*  count : read bytes
*  offset : the offset of file
*/
probe nfsd.commit = kernel.function("nfsd_commit")!,
                    module("nfsd").function("nfsd_commit")?
{
	fh = __svc_fh($fhp)

	count = $count
	offset = $offset
	flag = $fhp->fh_export->ex_flags

	name = "nfsd.commit"
	argstr = sprintf("%d,%d",count,offset)

	size = count 
	units = "bytes"
}

probe nfsd.commit.return = kernel.function("nfsd_commit").return!,
                    module("nfsd").function("nfsd_commit").return ?
{
	name = "nfsd.commit.return"
	retstr = sprintf("%d",$return)
}

/*
*probe nfsd.lookup
*  Fires when client opens/searchs file on server
*
*Arguments:
*  fh  : file handle of parent dir(the first part is the length of the file handle)
*  filename : file name 
*  filelen  : the length of file name
*/

probe nfsd.lookup = kernel.function("nfsd_lookup")!,
                    module("nfsd").function("nfsd_lookup")?
{
	fh = __svc_fh($fhp)

	filelen = $len
	filename = kernel_string_n($name, filelen)

	name = "nfsd.lookup"
	argstr = sprintf("%s",filename)
}

probe nfsd.lookup.return = kernel.function("nfsd_lookup").return!,
                            module("nfsd").function("nfsd_lookup").return?
{
	name = "nfsd.lookup.return"
	retstr = sprintf("%d",$return)
}
/*
* probe nfsd.create
*  Fires when client creates a file(regular,dir,device,fifo) on server side,
*  sometimes nfsd will call nfsd_create_v3 instead of this function
*
* Arguments:
*
*  fh  : file handle (the first part is the length of the file handle)
*  filename : file name 
*  filelen  : the length of file name
*  type : file type(regular,dir,device,fifo ...)
*  iap_valid: Attribute flags
*  iap_mode : file access mode
*/
probe nfsd.create = kernel.function("nfsd_create")!,         
                    module("nfsd").function("nfsd_create")?
{
	fh = __svc_fh($fhp)

	filelen = $flen
	filename = kernel_string_n($fname, filelen)
	type = $type
	iap_valid = $iap->ia_valid
	iap_mode = $iap->ia_mode

	name = "nfsd.create"
	argstr = sprintf("%s,%d",filename,type)
}

probe nfsd.create.return = kernel.function("nfsd_create").return!,         
                    module("nfsd").function("nfsd_create").return?
{
	name = "nfsd.create.return"
	retstr = sprintf("%d",$return)
}

/*
* probe nfsd.createv3
*  Fires when client creates a regular file or set file attributes on server side,
*  only called by nfsd3_proc_create and nfsd4_open(op_claim_type is NFS4_OPEN_CLAIM_NULL)
*
* Arguments:
*
*  fh  : file handle (the first part is the length of the file handle)
*  filename : file name 
*  filelen  : the length of file name
*  iap_valid: Attribute flags
*  iap_mode : file access mode
*  createmode : create mode .The possible values could be:
*	NFS3_CREATE_EXCLUSIVE,NFS3_CREATE_UNCHECKED,NFS3_CREATE_GUARDED
*  truncp : trunp arguments, indicates if the file shouldbe truncate
*  verfier :  file attributes (atime,mtime,mode).It's used to reset file
              attributes for CREATE_EXCLUSIVE
*/
probe nfsd.createv3 = kernel.function("nfsd_create_v3")!,         
                    module("nfsd").function("nfsd_create_v3")?
{
	fh = __svc_fh($fhp)

	filelen = $flen
	filename = kernel_string_n($fname, filelen)
	iap_valid = $iap->ia_valid
	iap_mode = $iap->ia_mode
	truncp = $truncp
	verfier = $verifier
	createmode = $createmode

	name = "nfsd.createv3"
	argstr = sprintf("%s,%d",filename,createmode)
}

probe nfsd.createv3.return = kernel.function("nfsd_create_v3").return!,         
                    module("nfsd").function("nfsd_create_v3").return?
{
	name = "nfsd.createv3.return"
	retstr = sprintf("%d",$return)
}

/*
* probe nfsd.unlink
*  Fires when client removes a file or a dir  on server side,
*
* Arguments:
*
*  fh  : file handle (the first part is the length of the file handle)
*  filename : file name 
*  filelen  : the length of file name
*  type : file type(file or dir)
*/
probe nfsd.unlink = kernel.function("nfsd_unlink")!,         
                    module("nfsd").function("nfsd_unlink")?
{
	fh = __svc_fh($fhp)

	filelen = $flen
	filename = kernel_string_n($fname, filelen)
	type = $type

	name = "nfsd.unlink"
	argstr = sprintf("%s,%d",filename,type)
}

probe nfsd.unlink.return = kernel.function("nfsd_unlink").return!,         
                    module("nfsd").function("nfsd_unlink").return?
{
	name = "nfsd.unlink.return"
	retstr = sprintf("%d",$return)
}

/*
* probe nfsd.rename
*  Fires when clients rename a file on server side
*
* Arguments:
*   fh : file handler of old path
*   tfh : file handler of new path
*   filename : old file name 
*   tname : new file name
*   flen : length of old file name 
*   tlen : length of new file name
*/

probe nfsd.rename =  kernel.function("nfsd_rename")!,
                           module("nfsd").function("nfsd_rename")?
{
	fh = __svc_fh($ffhp)
	tfh = __svc_fh($tfhp)

	filelen = $flen
	filename  = kernel_string_n($fname, filelen)
	tlen = $tlen
	tname = kernel_string_n($tname, tlen)

	name = "nfsd.rename"
	argstr = sprintf("%s,%s",filename,tname)
}

probe nfsd.rename.return =  kernel.function("nfsd_rename").return!,
                           module("nfsd").function("nfsd_rename").return?
{
	name = "nfsd.rename.return"
	retstr = sprintf("%d",$return)
}
