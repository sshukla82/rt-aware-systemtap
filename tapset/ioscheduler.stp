// IO scheduler tapset
// Copyright (C) 2005, 2006 IBM Corp.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
#include <linux/blkdev.h>
#include <linux/elevator.h>
%}

probe ioscheduler.elv_next_request
	=  kernel.function("elv_next_request")
        @@ "Probe the retrieval of a I/O request from request queue."
{
        elevator_name =
        %( kernel_v >= "2.6.10" %?
           kernel_string($q->elevator->elevator_type->elevator_name) %:
           kernel_string($q->elevator->elevator_name) %)
        @@ "The elevator name."
}

probe ioscheduler.elv_next_request.return
	= kernel.function("elv_next_request").return
        @@ "Probe the return from a I/O request retrieval."
{
	if($return == 0)  {
		req = 0          @@ "Address of the request."
		req_flags = 0    @@ "Request flags."
		disk_major = -1  @@ "Disk major number of the request."
		disk_minor = -1  @@ "Disk minor number of the request."
	} else {
		req = $return
%( kernel_v >= "2.6.19" %?
		req_flags = $return->cmd_flags
%:
		req_flags = $return->flags
%)
		if($return->rq_disk == 0)  {
			disk_major = -1
			disk_minor = -1
		} else {
			disk_major = $return->rq_disk->major
			disk_minor = $return->rq_disk->first_minor
		}
	}
}

/* when a request is added to the request queue */
probe ioscheduler.elv_add_request
	= kernel.function("__elv_add_request")
        @@ "Probe adding a request into the I/O request queue."
{
%( kernel_v >= "2.6.10" %?
	elevator_name = kernel_string($q->elevator->elevator_type->elevator_name)
%:
	elevator_name = kernel_string($q->elevator->elevator_name)
%)      @@ "The elevator name."

	if($rq == 0)  {
		disk_major = -1   @@ "Disk major number of the request."
		disk_minor = -1   @@ "Disk minor number of the request."
	} else {
		if($rq->rq_disk == 0)  {
			disk_major = -1
			disk_minor = -1
		} else {
			disk_major = $rq->rq_disk->major
			disk_minor = $rq->rq_disk->first_minor
		}
	}

	req = $rq   @@ "Address of the request."
%( kernel_v >= "2.6.19" %?
	req_flags = $rq==0? 0:$rq->cmd_flags
%:
	req_flags = $rq==0? 0:$rq->flags
%)      @@ "Request flags."
}

/* when a request is completed */
probe ioscheduler.elv_completed_request
	= kernel.function("elv_completed_request")
{
%( kernel_v >= "2.6.10" %?
	elevator_name = kernel_string($q->elevator->elevator_type->elevator_name)
%:
	elevator_name = kernel_string($q->elevator->elevator_name)
%)
	if($rq == 0)  {
		disk_major = -1
		disk_minor = -1
	} else {
		if($rq->rq_disk == 0)  {
			disk_major = -1
			disk_minor = -1
		} else {
			disk_major = $rq->rq_disk->major
			disk_minor = $rq->rq_disk->first_minor
		}
	}

	req = $rq
%( kernel_v >= "2.6.19" %?
	req_flags = $rq==0? 0:$rq->cmd_flags
%:
	req_flags = $rq==0? 0:$rq->flags
%)
}

function disk_major_from_request:long(var_q:long)
%{ /* pure */
	struct request_queue *q = (struct request_queue *)((long)THIS->var_q);
	struct list_head *queue_head = &(q->queue_head);

	if (list_empty(&(q->queue_head))) /* FIXME: deref hazard! */
		THIS->__retvalue = -1;
	else  {
		struct request *rq = list_entry_rq(q->queue_head.next); /* FIXME: deref hazard! */
		struct gendisk *rq_disk = kread(&(rq->rq_disk));
		THIS->__retvalue = kread(&(rq_disk->major));
	}
	CATCH_DEREF_FAULT();
%}

function disk_minor_from_request:long(var_q:long)
%{ /* pure */
	struct request_queue *q = (struct request_queue *)((long)THIS->var_q);
	struct list_head *queue_head = &(q->queue_head);

	if (list_empty(&(q->queue_head))) /* FIXME: deref hazard! */
		THIS->__retvalue = -1;
	else  {
		struct request *rq = list_entry_rq(q->queue_head.next); /* FIXME: deref hazard! */
		struct gendisk *rq_disk = kread(&(rq->rq_disk));
		THIS->__retvalue = kread(&(rq_disk->first_minor));
	}
	CATCH_DEREF_FAULT();
%}
